<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Loot Spin Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Comfortaa&display=swap" rel="stylesheet">
  <link href="style.css" rel="stylesheet">
</head>
<body>
  <div class="confetti-container" id="confettiContainer"></div>
  <div class="container">
    <div class="forge">
      <h2>🔮 The Forge</h2>
      <div class="forge-slots" id="forgeSlots">
        <div class="forge-slot" data-slot="0">Forge Slot 1</div>
        <div class="forge-slot" data-slot="1">Forge Slot 2</div>
        <div class="forge-slot" data-slot="2">Forge Slot 3</div>
      </div>
      <button class="forge-button" onclick="forgeCards()">Forge Cards</button>
      <div class="code-redeemer">
        <input type="text" id="codeInput" placeholder="Enter code">
        <button onclick="redeemCode()">Redeem</button>
      </div>
      <div class="save-load">
        <textarea id="saveCode" placeholder="Save/load code here"></textarea>
        <div style="display: flex; gap: 10px;">
          <button onclick="saveGame(true)">Save Game</button>
          <button onclick="loadGame()">Load Game</button>
        </div>
      </div>
      <div class="forgable-list">
        <h3>🛠️ Forgable Items:</h3>
        <ul id="forgableList"></ul>
      </div>
    </div>
    <div class="game-container">
      <h1>🎰 Loot Spin</h1>
      <div class="coin-counter">💰 Coins: <span id="coinCounter">100</span></div>
      <button class="spin-button" onclick="spin()">Spin (Cost: <span id="spinCost">10</span> Coins)</button>
      <div id="result" class="item-card"></div>
      <div class="slots" id="slots">
        <div class="slot" data-slot="0"><div class="slot-content">Slot 1</div></div>
        <div class="slot" data-slot="1"><div class="slot-content">Slot 2</div></div>
        <div class="slot" data-slot="2"><div class="slot-content">Slot 3</div></div>
        <div class="slot" data-slot="3"><div class="slot-content">Slot 4</div></div>
        <div class="slot" data-slot="4"><div class="slot-content">Slot 5</div></div>
      </div>
      <div class="inventory">
        <h3>🎒 Inventory:</h3>
        <ul id="inventoryList"></ul>
      </div>
      <div class="changelog">
        <h3>📜 Changelog & Credits</h3>
        <ul id="changelogList"></ul>
      </div>
    </div>
    <div class="upgrade-altar">
      <h2>🔥 Upgrade Altar</h2>
      <div class="target-slot" id="altarTarget">Target Slot</div>
      <div class="fuel-slots" id="fuelSlots">
        <div class="fuel-slot" data-slot="0">Fuel Slot 1</div>
        <div class="fuel-slot" data-slot="1">Fuel Slot 2</div>
        <div class="fuel-slot" data-slot="2">Fuel Slot 3</div>
        <div class="fuel-slot" data-slot="3">Fuel Slot 4</div>
        <div class="fuel-slot" data-slot="4">Fuel Slot 5</div>
      </div>
      <button class="upgrade-button" onclick="upgradeCard()">Upgrade Card</button>
      <div class="batch-selection">
        <select id="batchRarity">
          <option value="">Select Rarity</option>
          <option value="Common">Common</option>
          <option value="Uncommon">Uncommon</option>
          <option value="Rare">Rare</option>
          <option value="SuperRare">SuperRare</option>
          <option value="Epic">Epic</option>
          <option value="Legendary">Legendary</option>
          <option value="Mythical">Mythical</option>
          <option value="Celestial">Celestial</option>
          <option value="Special">Special</option>
          <option value="???">Developer</option>
        </select>
        <input type="number" id="batchCPS" min="0" placeholder="Enter CPS (0-1000)" title="Enter a CPS value between 0 and 1000">
        <button onclick="batchSelectFuelCards()">Select</button>
      </div>
      <div class="fuel-card-list">
        <h3>⛽ Fuel Cards:</h3>
        <ul id="fuelCardList"></ul>
      </div>
    </div>
  </div>

  <script>
    let coins = 100;
    let spinCost = 10;
    const inventory = [];
    const equipped = [null, null, null, null, null];
    const forgeSlots = [null, null, null];
    let altarTarget = null;
    const altarFuel = [null, null, null, null, null];
    let selectedItem = null;
    let selectedSource = null; // 'inventory', 'forgable', or 'fuel'
    const redeemedCodes = new Set();
    const changelog = [
  { text: "Update 1.1: Added Upgrade Altar", timestamp: "2025-05-08 14:11:27" },
  { text: "Update 1.2: Added saving of game", timestamp: "2025-05-08 21:30:55" }
];
    const rarityOrder = { 
      Developer: 10,
      Special: 9, 
      Celestial: 8, 
      Mythical: 7, 
      Legendary: 6, 
      Epic: 5, 
      SuperRare: 4, 
      Rare: 3, 
      Uncommon: 2, 
      Common: 1 
    };
    const rarityProgression = [
      'Common', 'Uncommon', 'Rare', 'SuperRare', 
      'Epic', 'Legendary', 'Mythical', 'Celestial', 'Special'
    ];

    const items = [
      // Common Items (40% total chance, 12 items)
      { name: "Chocolate Frog", rarity: "Common", emoji: "🐸", cps: 1, chance: 0.05, description: "A sweet that hops around, comes with a wizard card." },
      { name: "Bertie Bott's Beans", rarity: "Common", emoji: "🍬", cps: 1, chance: 0.05, description: "Jelly beans with flavors like earwax or chocolate." },
      { name: "Hogwarts Letter", rarity: "Common", emoji: "✉️", cps: 2, chance: 0.04, description: "Your acceptance letter to Hogwarts!" },
      { name: "Broken Wand", rarity: "Common", emoji: "🪄", cps: 1, chance: 0.04, description: "Sparks occasionally, but unreliable." },
      { name: "Old Cauldron", rarity: "Common", emoji: "⚗️", cps: 2, chance: 0.04, description: "Dented but functional for basic potions." },
      { name: "Potion Book", rarity: "Common", emoji: "📖", cps: 1, chance: 0.03, description: "Contains recipes for simple potions." },
      { name: "Scabbers", rarity: "Common", emoji: "🐀", cps: 1, chance: 0.03, description: "Ron's suspicious pet rat." },
      { name: "Quill", rarity: "Common", emoji: "✍️", cps: 1, chance: 0.03, description: "A standard feather quill for spell writing." },
      { name: "Parchment", rarity: "Common", emoji: "📜", cps: 1, chance: 0.03, description: "Used for homework and spell notes." },
      { name: "Hogwarts Textbook", rarity: "Common", emoji: "📚", cps: 2, chance: 0.02, description: "A basic spellbook or history text." },
      { name: "Pumpkin Pasty", rarity: "Common", emoji: "🥟", cps: 1, chance: 0.02, description: "A savory snack from the Hogwarts Express." },
      { name: "Sneakoscope", rarity: "Common", emoji: "🔍", cps: 1, chance: 0.02, description: "Spins when someone untrustworthy is near." },

      // Uncommon Items (25% total chance, 10 items)
      { name: "Marauder's Map", rarity: "Uncommon", emoji: "🗺️", cps: 3, chance: 0.04, description: "Shows everyone's location at Hogwarts." },
      { name: "Extendable Ears", rarity: "Uncommon", emoji: "👂", cps: 3, chance: 0.04, description: "Eavesdrop through walls with these." },
      { name: "Fizzing Whizbees", rarity: "Uncommon", emoji: "🍯", cps: 2, chance: 0.03, description: "Sweets that make you levitate slightly." },
      { name: "Nimbus 2000", rarity: "Uncommon", emoji: "🧹", cps: 4, chance: 0.03, description: "A decent Quidditch broom." },
      { name: "Remembrall", rarity: "Uncommon", emoji: "🔮", cps: 2, chance: 0.03, description: "Glows red when you forget something." },
      { name: "Quick-Quotes Quill", rarity: "Uncommon", emoji: "✍️", cps: 3, chance: 0.02, description: "Writes exaggerated stories automatically." },
      { name: "Hogsmeade Permission", rarity: "Uncommon", emoji: "📝", cps: 2, chance: 0.02, description: "Grants access to Hogsmeade weekends." },
      { name: "Butterbeer", rarity: "Uncommon", emoji: "🍺", cps: 2, chance: 0.02, description: "A frothy, non-alcoholic drink." },
      { name: "Gobstones", rarity: "Uncommon", emoji: "🎲", cps: 2, chance: 0.01, description: "A game that squirts losers with goo." },
      { name: "Spellotape", rarity: "Uncommon", emoji: "🩹", cps: 2, chance: 0.01, description: "Magical tape for fixing wands." },

      // Rare Items (15% total chance, 8 items)
      { name: "Invisibility Cloak", rarity: "Rare", emoji: "🧥", cps: 5, chance: 0.03, description: "Hides you from most eyes." },
      { name: "Time-Turner", rarity: "Rare", emoji: "⏳", cps: 6, chance: 0.025, description: "Travel back in time, use cautiously." },
      { name: "Howler", rarity: "Rare", emoji: "🔴", cps: 4, chance: 0.02, description: "Screams its message at the recipient." },
      { name: "Firebolt", rarity: "Rare", emoji: "🧹", cps: 7, chance: 0.02, description: "The fastest Quidditch broom ever." },
      { name: "Deluminator", rarity: "Rare", emoji: "💡", cps: 5, chance: 0.015, description: "Steals and stores light." },
      { name: "Polyjuice Potion", rarity: "Rare", emoji: "🧪", cps: 6, chance: 0.015, description: "Transform into someone else for an hour." },
      { name: "Sneakoscope", rarity: "Rare", emoji: "🔍", cps: 4, chance: 0.01, description: "A more reliable dark detector." },
      { name: "Mandrake", rarity: "Rare", emoji: "🌱", cps: 5, chance: 0.01, description: "Its cry is fatal, handle with care." },

      // Super Rare Items (10% total chance, 6 items)
      { name: "Felix Felicis", rarity: "SuperRare", emoji: "🍀", cps: 10, chance: 0.025, description: "Liquid luck for a perfect day." },
      { name: "Triwizard Cup", rarity: "SuperRare", emoji: "🏆", cps: 12, chance: 0.02, description: "Glows with tournament magic." },
      { name: "Thestral", rarity: "SuperRare", emoji: "🐎", cps: 11, chance: 0.02, description: "Only visible to those who’ve seen death." },
      { name: "Pensieve", rarity: "SuperRare", emoji: "🪣", cps: 10, chance: 0.015, description: "View and analyze memories." },
      { name: "Mirror of Erised", rarity: "SuperRare", emoji: "🪞", cps: 9, chance: 0.01, description: "Shows your heart’s deepest desire." },
      { name: "Mad-Eye’s Eye", rarity: "SuperRare", emoji: "👁️", cps: 10, chance: 0.01, description: "Sees through walls and cloaks." },

      // Epic Items (5% total chance, 5 items)
      { name: "Phoenix Feather", rarity: "Epic", emoji: "🔥", cps: 15, chance: 0.015, description: "Bursts with regenerative magic." },
      { name: "Goblet of Fire", rarity: "Epic", emoji: "🔥", cps: 16, chance: 0.012, description: "Chooses worthy champions." },
      { name: "Veil", rarity: "Epic", emoji: "🚪", cps: 14, chance: 0.01, description: "A mysterious archway to the beyond." },
      { name: "Room of Requirement", rarity: "Epic", emoji: "🏰", cps: 15, chance: 0.008, description: "Appears when you need it most." },
      { name: "Patronus Charm", rarity: "Epic", emoji: "🦌", cps: 13, chance: 0.005, description: "Summons a protective spirit." },

      // Legendary Items (3% total chance, 4 items)
      { name: "Elder Wand", rarity: "Legendary", emoji: "🌟", cps: 20, chance: 0.01, description: "The most powerful wand in existence." },
      { name: "Resurrection Stone", rarity: "Legendary", emoji: "🪙", cps: 18, chance: 0.008, description: "Summons shadows of the dead." },
      { name: "Cloak of Invisibility", rarity: "Legendary", emoji: "🕴️", cps: 22, chance: 0.007, description: "True invisibility, a Deathly Hallow." },
      { name: "Sword of Gryffindor", rarity: "Legendary", emoji: "⚔️", cps: 25, chance: 0.005, description: "Appears to worthy Gryffindors." },

      // Mythical Items (1.5% total chance, 3 items)
      { name: "Horcrux", rarity: "Mythical", emoji: "💍", cps: 30, chance: 0.006, description: "A dark object containing a soul fragment." },
      { name: "Philosopher’s Stone", rarity: "Mythical", emoji: "🪨", cps: 35, chance: 0.005, description: "Grants immortality and gold." },
      { name: "Fawkes", rarity: "Mythical", emoji: "🦅", cps: 32, chance: 0.004, description: "Dumbledore’s loyal phoenix." },

      // Celestial Items (0.5% total chance, 2 items)
      { name: "Deathly Hallows", rarity: "Celestial", emoji: "🔺", cps: 50, chance: 0.003, description: "Mastery over death itself." },
      { name: "Hogwarts Castle", rarity: "Celestial", emoji: "🏰", cps: 60, chance: 0.002, description: "The magical heart of the wizarding world." },

      // Special Items (0.4% total chance, 8 items)
      { name: "Harry’s Scar", rarity: "Special", emoji: "⚡️", cps: 70, chance: 0.0015, description: "A mark of survival and connection to Voldemort." },
      { name: "Dumbledore’s Army", rarity: "Special", emoji: "🪖", cps: 65, chance: 0.001, description: "A rebellious group of brave students." },
      { name: "Snitch", rarity: "Special", emoji: "🏐", cps: 60, chance: 0.001, description: "The elusive prize of Quidditch." },
      { name: "Sorting Hat", rarity: "Special", emoji: "🎩", cps: 75, chance: 0.0005, description: "Chooses your Hogwarts house with wisdom." },
      { name: "Professor McGonagall", rarity: "Special", emoji: "🧙‍♀️", cps: 50, chance: 0, description: "A strict but fair Transfiguration teacher." },
      { name: "Ella", rarity: "Special", emoji: "🦖", cps: 50, chance: 0, description: "Rawr..." },
      { name: "Nirvi", rarity: "Special", emoji: "🐒", cps: 40, chance: 0, description: "A peculiar monkey." },
      { name: "Matthew Tan", rarity: "Special", emoji: "🤯", cps: 45, chance: 0, description: "Thinks he's smart." },
      { name: "Bookworm", rarity: "Special", emoji: "🌳", cps: 100, chance: 0, description: "I like Keeper of the Lost Cities :D"},

      // ??? Items (0% total chance, 1 items)
      { name: "Developer", rarity: "???", emoji: "😈", cps: 415, chance: 0,description: "Syntax Error: Code Not Found" }
    ];
    function generateChecksum(state) {
  const cleanState = {
    coins: Math.floor(state.coins || 0),
    spinCost: Math.floor(state.spinCost || 0),
    inventory: state.inventory ? state.inventory.map(item => ({
      name: item.name,
      rarity: item.rarity,
      cps: Math.floor(item.cps),
      emoji: item.emoji,
      description: item.description
    })) : [],
    equipped: state.equipped ? state.equipped.map(item => item ? ({
      name: item.name,
      rarity: item.rarity,
      cps: Math.floor(item.cps),
      emoji: item.emoji,
      description: item.description
    }) : null) : [null, null, null, null, null],
    forgeSlots: state.forgeSlots ? state.forgeSlots.map(item => item ? ({
      name: item.name,
      rarity: item.rarity,
      cps: Math.floor(item.cps),
      emoji: item.emoji,
      description: item.description
    }) : null) : [null, null, null],
    altarTarget: state.altarTarget ? {
      name: state.altarTarget.name,
      rarity: state.altarTarget.rarity,
      cps: Math.floor(state.altarTarget.cps),
      emoji: state.altarTarget.emoji,
      description: state.altarTarget.description
    } : null,
    altarFuel: state.altarFuel ? state.altarFuel.map(item => item ? ({
      name: item.name,
      rarity: item.rarity,
      cps: Math.floor(item.cps),
      emoji: item.emoji,
      description: item.description
    }) : null) : [null, null, null, null, null],
    redeemedCodes: state.redeemedCodes || [],
    changelog: state.changelog || []
  };

  const coinSum = cleanState.coins;
  const spinCostSum = cleanState.spinCost;
  const inventoryCount = cleanState.inventory.length;
  const equippedCount = cleanState.equipped.filter(item => item !== null).length;
  const forgeCount = cleanState.forgeSlots.filter(item => item !== null).length;
  const altarTargetCount = cleanState.altarTarget ? 1 : 0;
  const altarFuelCount = cleanState.altarFuel.filter(item => item !== null).length;
  const changelogCount = cleanState.changelog.length;

  const sum = coinSum + spinCostSum + inventoryCount + equippedCount + forgeCount + altarTargetCount + altarFuelCount + changelogCount;
  return sum % 65536;
}

function validateState(state) {
  if (!state || typeof state !== 'object') {
    console.error('Validation failed: State is not an object');
    return false;
  }

  if (typeof state.coins !== 'number' || isNaN(state.coins) || state.coins < 0 || state.coins > 1e9) {
    console.error('Validation failed: Invalid coins', state.coins);
    return false;
  }
  if (typeof state.spinCost !== 'number' || isNaN(state.spinCost) || state.spinCost < 10 || state.spinCost > 1e6) {
    console.error('Validation failed: Invalid spinCost', state.spinCost);
    return false;
  }

  if (!Array.isArray(state.inventory)) {
    console.error('Validation failed: Inventory is not an array');
    return false;
  }
  for (let i = 0; i < state.inventory.length; i++) {
    const item = state.inventory[i];
    if (!item || typeof item !== 'object') {
      console.error(`Validation failed: Invalid inventory item at index ${i}`, item);
      return false;
    }
    if (typeof item.name !== 'string' || !item.name.trim()) {
      console.error(`Validation failed: Invalid name for inventory item at index ${i}`, item.name);
      return false;
    }
    if (typeof item.rarity !== 'string' || (!rarityProgression.includes(item.rarity) && item.rarity !== 'Special')) {
      console.error(`Validation failed: Invalid rarity for inventory item at index ${i}`, item.rarity);
      return false;
    }
    if (typeof item.cps !== 'number' || isNaN(item.cps) || item.cps < 0 || item.cps > 1000) {
      console.error(`Validation failed: Invalid cps for inventory item at index ${i}`, item.cps);
      return false;
    }
    if (typeof item.emoji !== 'string') {
      console.error(`Validation failed: Invalid emoji for inventory item at index ${i}`, item.emoji);
      return false;
    }
    if (typeof item.description !== 'string') {
      console.error(`Validation failed: Invalid description for inventory item at index ${i}`, item.description);
      return false;
    }
  }

  if (!Array.isArray(state.equipped) || state.equipped.length !== 5) {
    console.error('Validation failed: Invalid equipped array', state.equipped);
    return false;
  }
  for (let i = 0; i < state.equipped.length; i++) {
    const item = state.equipped[i];
    if (item === null) continue;
    if (typeof item !== 'object') {
      console.error(`Validation failed: Invalid equipped item at index ${i}`, item);
      return false;
    }
    if (typeof item.name !== 'string' || !item.name.trim()) {
      console.error(`Validation failed: Invalid name for equipped item at index ${i}`, item.name);
      return false;
    }
    if (typeof item.rarity !== 'string' || (!rarityProgression.includes(item.rarity) && item.rarity !== 'Special')) {
      console.error(`Validation failed: Invalid rarity for equipped item at index ${i}`, item.rarity);
      return false;
    }
    if (typeof item.cps !== 'number' || isNaN(item.cps) || item.cps < 0 || item.cps > 1000) {
      console.error(`Validation failed: Invalid cps for equipped item at index ${i}`, item.cps);
      return false;
    }
    if (typeof item.emoji !== 'string') {
      console.error(`Validation failed: Invalid emoji for equipped item at index ${i}`, item.emoji);
      return false;
    }
    if (typeof item.description !== 'string') {
      console.error(`Validation failed: Invalid description for equipped item at index ${i}`, item.description);
      return false;
    }
  }

  if (!Array.isArray(state.forgeSlots) || state.forgeSlots.length !== 3) {
    console.error('Validation failed: Invalid forgeSlots array', state.forgeSlots);
    return false;
  }
  for (let i = 0; i < state.forgeSlots.length; i++) {
    const item = state.forgeSlots[i];
    if (item === null) continue;
    if (typeof item !== 'object') {
      console.error(`Validation failed: Invalid forgeSlots item at index ${i}`, item);
      return false;
    }
    if (typeof item.name !== 'string' || !item.name.trim()) {
      console.error(`Validation failed: Invalid name for forgeSlots item at index ${i}`, item.name);
      return false;
    }
    if (typeof item.rarity !== 'string' || (!rarityProgression.includes(item.rarity) && item.rarity !== 'Special')) {
      console.error(`Validation failed: Invalid rarity for forgeSlots item at index ${i}`, item.rarity);
      return false;
    }
    if (typeof item.cps !== 'number' || isNaN(item.cps) || item.cps < 0 || item.cps > 1000) {
      console.error(`Validation failed: Invalid cps for forgeSlots item at index ${i}`, item.cps);
      return false;
    }
    if (typeof item.emoji !== 'string') {
      console.error(`Validation failed: Invalid emoji for forgeSlots item at index ${i}`, item.emoji);
      return false;
    }
    if (typeof item.description !== 'string') {
      console.error(`Validation failed: Invalid description for forgeSlots item at index ${i}`, item.description);
      return false;
    }
  }

  if (state.altarTarget !== null && typeof state.altarTarget === 'object') {
    if (typeof state.altarTarget.name !== 'string' || !state.altarTarget.name.trim()) {
      console.error('Validation failed: Invalid name for altarTarget', state.altarTarget.name);
      return false;
    }
    if (typeof state.altarTarget.rarity !== 'string' || (!rarityProgression.includes(state.altarTarget.rarity) && state.altarTarget.rarity !== 'Special')) {
      console.error('Validation failed: Invalid rarity for altarTarget', state.altarTarget.rarity);
      return false;
    }
    if (typeof state.altarTarget.cps !== 'number' || isNaN(state.altarTarget.cps) || state.altarTarget.cps < 0 || state.altarTarget.cps > 1000) {
      console.error('Validation failed: Invalid cps for altarTarget', state.altarTarget.cps);
      return false;
    }
    if (typeof state.altarTarget.emoji !== 'string') {
      console.error('Validation failed: Invalid emoji for altarTarget', state.altarTarget.emoji);
      return false;
    }
    if (typeof state.altarTarget.description !== 'string') {
      console.error('Validation failed: Invalid description for altarTarget', state.altarTarget.description);
      return false;
    }
  } else if (state.altarTarget !== null) {
    console.error('Validation failed: Invalid altarTarget', state.altarTarget);
    return false;
  }

  if (!Array.isArray(state.altarFuel) || state.altarFuel.length !== 5) {
    console.error('Validation failed: Invalid altarFuel array', state.altarFuel);
    return false;
  }
  for (let i = 0; i < state.altarFuel.length; i++) {
    const item = state.altarFuel[i];
    if (item === null) continue;
    if (typeof item !== 'object') {
      console.error(`Validation failed: Invalid altarFuel item at index ${i}`, item);
      return false;
    }
    if (typeof item.name !== 'string' || !item.name.trim()) {
      console.error(`Validation failed: Invalid name for altarFuel item at index ${i}`, item.name);
      return false;
    }
    if (typeof item.rarity !== 'string' || (!rarityProgression.includes(item.rarity) && item.rarity !== 'Special')) {
      console.error(`Validation failed: Invalid rarity for altarFuel item at index ${i}`, item.rarity);
      return false;
    }
    if (typeof item.cps !== 'number' || isNaN(item.cps) || item.cps < 0 || item.cps > 1000) {
      console.error(`Validation failed: Invalid cps for altarFuel item at index ${i}`, item.cps);
      return false;
    }
    if (typeof item.emoji !== 'string') {
      console.error(`Validation failed: Invalid emoji for altarFuel item at index ${i}`, item.emoji);
      return false;
    }
    if (typeof item.description !== 'string') {
      console.error(`Validation failed: Invalid description for altarFuel item at index ${i}`, item.description);
      return false;
    }
  }

  if (!Array.isArray(state.redeemedCodes)) {
    console.error('Validation failed: Invalid redeemedCodes array', state.redeemedCodes);
    return false;
  }
  const validCodes = [
    btoa('imabeggar'), 
    btoa('ilovehomework'), 
    btoa('Ella'), 
    btoa('Nirvi'), 
    btoa('Idiot')
  ];
  for (let code of state.redeemedCodes) {
    if (!validCodes.includes(code) && code !== btoa('keybug02')) {
      console.error('Validation failed: Invalid redeemed code', code);
      return false;
    }
  }

  if (!Array.isArray(state.changelog)) {
    console.error('Validation failed: Invalid changelog array', state.changelog);
    return false;
  }
  for (let i = 0; i < state.changelog.length; i++) {
    const entry = state.changelog[i];
    if (!entry || typeof entry !== 'object') {
      console.error(`Validation failed: Invalid changelog entry at index ${i}`, entry);
      return false;
    }
    if (typeof entry.text !== 'string' || !entry.text.trim() || entry.text.length > 200) {
      console.error(`Validation failed: Invalid text for changelog entry at index ${i}`, entry.text);
      return false;
    }
    if (typeof entry.timestamp !== 'string' || !entry.timestamp.trim()) {
      console.error(`Validation failed: Invalid timestamp for changelog entry at index ${i}`, entry.timestamp);
      return false;
    }
  }

  return true;
}

function saveGame(showCode = false) {
  try {
    const state = {
      coins: Math.floor(coins),
      spinCost: Math.floor(spinCost),
      inventory: inventory.map(item => ({
        name: item.name,
        rarity: item.rarity,
        cps: Math.floor(item.cps),
        emoji: item.emoji,
        description: item.description
      })),
      equipped: equipped.map(item => item ? ({
        name: item.name,
        rarity: item.rarity,
        cps: Math.floor(item.cps),
        emoji: item.emoji,
        description: item.description
      }) : null),
      forgeSlots: forgeSlots.map(item => item ? ({
        name: item.name,
        rarity: item.rarity,
        cps: Math.floor(item.cps),
        emoji: item.emoji,
        description: item.description
      }) : null),
      altarTarget: altarTarget ? {
        name: altarTarget.name,
        rarity: altarTarget.rarity,
        cps: Math.floor(altarTarget.cps),
        emoji: altarTarget.emoji,
        description: altarTarget.description
      } : null,
      altarFuel: altarFuel.map(item => item ? ({
        name: item.name,
        rarity: item.rarity,
        cps: Math.floor(item.cps),
        emoji: item.emoji,
        description: item.description
      }) : null),
      redeemedCodes: Array.from(redeemedCodes),
      changelog
    };
    const checksum = generateChecksum(state);
    const json = JSON.stringify(state);
    const encoded = btoa(encodeURIComponent(json)) + '.' + checksum;
    localStorage.setItem('lootSpinState', encoded);
    if (showCode) {
      const saveCodeEl = document.getElementById('saveCode');
      saveCodeEl.value = encoded;
      alert('Game saved! Copy the code from the textarea for backup.');
    }
  } catch (e) {
    console.error('Save failed:', e);
    alert('Failed to save game. Please try again.');
  }
}

function loadGame() {
  const saveCodeEl = document.getElementById('saveCode');
  let encoded = saveCodeEl.value.trim();
  if (!encoded) {
    encoded = localStorage.getItem('lootSpinState') || '';
  }
  if (!encoded) {
    alert('No save code provided or saved game found!');
    return;
  }

  try {
    const [data, checksum] = encoded.split('.');
    if (!data || !checksum) {
      console.error('Invalid save code format: Missing data or checksum');
      throw new Error('Invalid save code format');
    }
    const json = decodeURIComponent(atob(data));
    const state = JSON.parse(json);
    const expectedChecksum = generateChecksum(state);

    if (parseInt(checksum) !== expectedChecksum) {
      console.error('Checksum mismatch:', { 
        received: checksum, 
        expected: expectedChecksum, 
        coins: state.coins, 
        spinCost: state.spinCost, 
        inventoryLength: state.inventory.length,
        equippedCount: state.equipped.filter(item => item !== null).length,
        forgeCount: state.forgeSlots.filter(item => item !== null).length,
        altarTarget: state.altarTarget ? 1 : 0,
        altarFuelCount: state.altarFuel.filter(item => item !== null).length,
        changelogCount: state.changelog.length
      });
      alert('Invalid save code: Checksum mismatch! Check console for details.');
      return;
    }

    if (!validateState(state)) {
      console.error('State validation failed:', state);
      alert('Invalid save code: Data is corrupted or tampered! Check console for details.');
      return;
    }

    coins = state.coins;
    spinCost = state.spinCost;
    inventory.length = 0;
    inventory.push(...state.inventory);
    equipped.length = 0;
    equipped.push(...state.equipped);
    forgeSlots.length = 0;
    forgeSlots.push(...state.forgeSlots);
    altarTarget = state.altarTarget;
    altarFuel.length = 0;
    altarFuel.push(...state.altarFuel);
    redeemedCodes.clear();
    state.redeemedCodes.forEach(code => redeemedCodes.add(code));
    changelog.length = 0;
    changelog.push(...state.changelog);

    updateInventory();
    updateSpinButton();
    updateForgeSlots();
    updateSlots();
    updateForgableList();
    updateAltarTarget();
    updateFuelSlots();
    updateFuelCardList();
    updateChangelog();
    saveCodeEl.value = '';
    alert('Game loaded successfully!');
  } catch (e) {
    console.error('Load failed:', e.message, e.stack);
    alert('Failed to load game: Invalid save code! Check console for details.');
  }
}

    window.onload = () => {
  loadGame();
  // Validate slot states in place
  for (let i = 0; i < forgeSlots.length; i++) {
    forgeSlots[i] = forgeSlots[i] && forgeSlots[i].rarity && forgeSlots[i].name && Number.isInteger(forgeSlots[i].cps) && forgeSlots[i].cps >= 0 ? forgeSlots[i] : null;
  }
  altarTarget = altarTarget && altarTarget.rarity && altarTarget.name && Number.isInteger(altarTarget.cps) && altarTarget.cps >= 0 ? altarTarget : null;
  for (let i = 0; i < altarFuel.length; i++) {
    altarFuel[i] = altarFuel[i] && altarFuel[i].rarity && altarFuel[i].name && Number.isInteger(altarFuel[i].cps) && altarFuel[i].cps >= 0 ? altarFuel[i] : null;
  }
  for (let i = 0; i < equipped.length; i++) {
    equipped[i] = equipped[i] && equipped[i].rarity && equipped[i].name && Number.isInteger(equipped[i].cps) && equipped[i].cps >= 0 ? equipped[i] : null;
  }
  // Log equipped for debugging
  console.log('Equipped items:', equipped);
  // Ensure coins is valid
  if (typeof coins !== 'number' || isNaN(coins) || coins < 0) {
    coins = 100;
    console.log('Reset coins to 100');
  }
  // Clear inline backgrounds
  document.querySelectorAll('.forge-slot, .target-slot, .fuel-slot, .slot-content').forEach(el => {
    el.style.background = '';
  });
  updateInventory();
  updateSlots();
  updateForgeSlots();
  updateAltarTarget();
  updateFuelSlots();
  updateForgableList();
  updateFuelCardList();
  updateChangelog();
  updateSpinButton();
  setInterval(() => {
    collectCoins();
    console.log('collectCoins called');
  }, 1000);

  // Add event listeners for batch selection
  const batchRarity = document.getElementById('batchRarity');
  const batchCPS = document.getElementById('batchCPS');
  const batchButton = document.querySelector('.batch-selection button');
  batchRarity.addEventListener('change', () => batchButton.disabled = !batchRarity.value && !batchCPS.value);
  batchCPS.addEventListener('input', () => batchButton.disabled = !batchRarity.value && !batchCPS.value);
};

function collectCoins() {
  let totalCPS = 0;
  equipped.forEach(item => {
    if (item && Number.isInteger(item.cps) && item.cps >= 0) {
      totalCPS += item.cps;
    }
  });
  console.log('collectCoins: equipped=', equipped, 'totalCPS=', totalCPS, 'coins=', coins);
  coins += totalCPS;
  updateSpinButton();
  if (totalCPS > 0) {
    const coinCounter = document.getElementById('coinCounter');
    coinCounter.parentElement.classList.add('sparkle');
    setTimeout(() => coinCounter.parentElement.classList.remove('sparkle'), 500);
  }
  saveGame();
}
    function spin() {
      if (coins < spinCost) {
        alert("Not enough coins!");
        return;
      }
      coins -= spinCost;
      spinCost += 10;
      updateSpinButton();
      
      const totalChance = items.reduce((sum, item) => sum + item.chance, 0);
      let roll = Math.random() * totalChance;
      let cumulative = 0;
      let selectedItem = null;
      
      for (let item of items) {
        cumulative += item.chance;
        if (roll < cumulative) {
          selectedItem = { ...item };
          break;
        }
      }
      
      if (selectedItem) {
        if (inventory.length >= 1000) {
          alert("Inventory full! Please clear some items.");
          return;
        }
        inventory.push(selectedItem);
        showResult(selectedItem);
        updateInventory();
        
        if (selectedItem.rarity === "Celestial" || selectedItem.rarity === "Special" || selectedItem.rarity === "???") {
          showSpecialMessage(selectedItem);
        }
      }
      saveGame();
    }

    function showSpecialMessage(item) {
      const specialDiv = document.createElement('div');
      specialDiv.className = 'special-message';
      
      specialDiv.innerHTML = `
        <div class="special-content">
          <div class="special-title ${item.rarity}">✨ ${item.rarity.toUpperCase()} ITEM! ✨</div>
          <div class="special-item">${item.name} ${item.emoji}</div>
          <div>${item.description}</div>
          <div class="description-text">Generates ${item.cps} coins/sec!</div>
          <button class="close-special" onclick="this.parentElement.parentElement.remove()">
            CELEBRATE!
          </button>
        </div>
      `;
      
      document.body.appendChild(specialDiv);
      createConfetti(item.rarity);
    }

    function createConfetti(rarity) {
      const colorMap = {
        Celestial: ['#00b7eb', '#0097c7', '#e6f7ff'],
        Special: ['#dc143c', '#ff4500', '#ffd700'],
        Developer:['#ff07c5', '#ff00e6', '#fc44f0']
      };
      const colors = colorMap[rarity] || ['#ff0000', '#ff4500', '#ffd700', '#ffffff'];
      const confettiContainer = document.getElementById('confettiContainer');
      
      for (let i = 0; i < 100; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        const leftPos = Math.random() < 0.5 ? Math.random() * 30 : 70 + Math.random() * 30;
        confetti.style.left = leftPos + 'vw';
        confetti.style.top = -10 + 'px';
        confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
        
        const size = Math.random() * 10 + 5;
        confetti.style.width = size + 'px';
        confetti.style.height = size + 'px';
        
        confettiContainer.appendChild(confetti);
        
        const animationDuration = Math.random() * 3 + 2;
        
        confetti.animate([
          { top: '-10px', opacity: 1, transform: `rotate(${Math.random() * 360}deg)` },
          { top: '100vh', opacity: 0, transform: `rotate(${Math.random() * 360}deg)` }
        ], {
          duration: animationDuration * 1000,
          easing: 'cubic-bezier(0.1, 0.8, 0.9, 1)'
        });
        
        setTimeout(() => confetti.remove(), animationDuration * 1000);
      }
    }

    function showResult(item) {
      const resultDiv = document.getElementById("result");
      resultDiv.innerHTML = `
        <div>🎉 You won: ${item.name} ${item.emoji}</div>
        <div class="description-text">Description: ${item.description}</div>
        <div class="description-text">Generates ${item.cps} coins/sec</div>
      `;
      resultDiv.className = `item-card ${item.rarity}`;
    }

    function updateSpinButton() {
      const coinCounter = document.getElementById("coinCounter");
      const spinCostEl = document.getElementById("spinCost");
      coinCounter.textContent = Math.floor(coins);
      spinCostEl.textContent = spinCost;
    }

    function updateInventory(forgedCardName = null) {
  const list = document.getElementById("inventoryList");
  list.innerHTML = "";
  const sorted = [...inventory].sort((a, b) => {
    if (b.cps !== a.cps) return b.cps - a.cps;
    if (rarityOrder[b.rarity] !== rarityOrder[a.rarity]) return rarityOrder[b.rarity] - rarityOrder[a.rarity];
    return a.name.localeCompare(b.name);
  });
  sorted.forEach((item, i) => {
    const li = document.createElement("li");
    li.innerHTML = `
      ${item.name} ${item.emoji} (${item.rarity})
      <div class="description-text">${item.cps} coins/sec</div>
      <span class="tooltip">${item.description}</span>
    `;
    li.className = `${item.rarity}-li`;
    if (forgedCardName && item.name === forgedCardName && item.rarity === forgedCardName.rarity) {
      li.classList.add('forged-card');
      setTimeout(() => li.classList.remove('forged-card'), 1000);
    }
    li.dataset.index = inventory.indexOf(item);
    li.addEventListener('click', () => selectItem(item, li, 'inventory'));
    if (selectedItem && selectedItem.name === item.name && selectedItem.rarity === item.rarity && selectedItem.cps === item.cps && selectedSource === 'inventory') {
      li.classList.add('selected');
    }
    list.appendChild(li);
  });
  updateForgableList();
  updateFuelCardList();
}

    function updateForgableList() {
      const list = document.getElementById("forgableList");
      list.innerHTML = "";
      
      const itemCounts = {};
      inventory.forEach(item => {
        if (item.rarity !== "???" || item.rarity !== "Special") {
          const key = `${item.name}|${item.rarity}`;
          if (!itemCounts[key]) {
            itemCounts[key] = { count: 0, item: item };
          }
          itemCounts[key].count++;
        }
      });

      const forgableItems = Object.values(itemCounts)
        .filter(data => data.count >= 3)
        .map(data => ({
          ...data.item,
          count: data.count
        }));

      const sorted = forgableItems.sort((a, b) => {
        if (b.cps !== a.cps) return b.cps - a.cps;
        if (rarityOrder[b.rarity] !== rarityOrder[a.rarity]) return rarityOrder[b.rarity] - rarityOrder[a.rarity];
        return a.name.localeCompare(b.name);
      });

      sorted.forEach(item => {
        const li = document.createElement("li");
        li.innerHTML = `
          ${item.name} ${item.emoji} (${item.rarity}, x${item.count})
          <div class="description-text">${item.cps} coins/sec</div>
          <span class="tooltip">${item.description}</span>
        `;
        li.className = `${item.rarity}-li`;
        li.addEventListener('click', () => selectItem(item, li, 'forgable'));
        if (selectedItem && selectedItem.name === item.name && selectedItem.rarity === item.rarity && selectedSource === 'forgable') {
          li.classList.add('selected');
        }
        list.appendChild(li);
      });
    }

    function updateFuelCardList() {
      const list = document.getElementById("fuelCardList");
      list.innerHTML = "";
      
      const itemCounts = {};
      inventory.forEach(item => {
        const key = `${item.name}|${item.rarity}`;
        if (!itemCounts[key]) {
          itemCounts[key] = { count: 0, item: item };
        }
        itemCounts[key].count++;
      });

      const fuelItems = Object.values(itemCounts).map(data => ({
        ...data.item,
        count: data.count
      }));

      const sorted = fuelItems.sort((a, b) => {
        if (b.cps !== a.cps) return b.cps - a.cps;
        if (rarityOrder[b.rarity] !== rarityOrder[a.rarity]) return rarityOrder[b.rarity] - rarityOrder[a.rarity];
        return a.name.localeCompare(b.name);
      });

      sorted.forEach(item => {
        const li = document.createElement("li");
        li.innerHTML = `
          ${item.name} ${item.emoji} (${item.rarity}, x${item.count})
          <div class="description-text">${item.cps} coins/sec</div>
          <span class="tooltip">${item.description}</span>
        `;
        li.className = `${item.rarity}-li`;
        li.addEventListener('click', () => selectItem(item, li, 'fuel'));
        if (selectedItem && selectedItem.name === item.name && selectedItem.rarity === item.rarity && selectedSource === 'fuel') {
          li.classList.add('selected');
        }
        list.appendChild(li);
      });
    }

    function updateChangelog() {
      const list = document.getElementById("changelogList");
      list.innerHTML = `
        <li>Designed by <a onclick="window.open('https://github.com/ElyakProductionsCo', '_blank')">ElyakProductionsCo</a></li>
      `;
      changelog.slice().reverse().forEach(entry => {
        const li = document.createElement("li");
        li.textContent = `${entry.timestamp}: ${entry.text}`;
        list.insertBefore(li, list.firstChild.nextSibling);
      });
    }

    function addChangelogEntry() {
  const entry = prompt("Enter changelog entry (max 200 characters):");
  if (entry && entry.trim() && entry.length <= 200) {
    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);
    changelog.push({ text: entry.trim(), timestamp });
    updateChangelog();
    saveGame();
    alert("Changelog updated!");
  } else if (entry) {
    alert("Entry must be non-empty and up to 200 characters!");
  }
}

    function selectItem(item, element, source) {
  if (selectedItem && selectedItem.name === item.name && selectedItem.rarity === item.rarity && selectedItem.cps === item.cps && selectedSource === source) {
    selectedItem = null;
    selectedSource = null;
    updateInventory();
    updateForgableList();
    updateFuelCardList();
  } else {
    selectedItem = item;
    selectedSource = source;
    if (source === 'forgable') {
      autoPlaceForgable(item);
    } else if (source === 'fuel') {
      autoPlaceFuel(item);
    } else {
      updateInventory();
      updateForgableList();
      updateFuelCardList();
    }
  }
}

function autoPlaceForgable(item) {
  const matchingItems = inventory.filter(i => i.name === item.name && i.rarity === item.rarity);
  if (matchingItems.length < 3) {
    alert("Not enough matching items in inventory!");
    selectedItem = null;
    selectedSource = null;
    updateInventory();
    updateForgableList();
    return;
  }
  forgeSlots.forEach((slotItem, i) => {
    if (slotItem) {
      inventory.push(slotItem);
      forgeSlots[i] = null;
    }
  });
  for (let i = 0; i < 3; i++) {
    forgeSlots[i] = { ...matchingItems[i] };
  }
  let removedCount = 0;
  for (let i = inventory.length - 1; i >= 0 && removedCount < 3; i--) {
    if (inventory[i].name === item.name && inventory[i].rarity === item.rarity) {
      inventory.splice(i, 1);
      removedCount++;
    }
  }
  selectedItem = null;
  selectedSource = null;
  updateInventory();
  updateForgeSlots();
  updateForgableList();
  saveGame();
}

function autoPlaceFuel(item) {
  if (altarTarget && item.name === altarTarget.name && item.rarity === altarTarget.rarity && item.cps === altarTarget.cps) {
    alert("Cannot use the target card as a fuel card!");
    selectedItem = null;
    selectedSource = null;
    updateInventory();
    updateFuelCardList();
    return;
  }
  const matchingItems = inventory.filter(i => i.name === item.name && i.rarity === item.rarity && i.cps === item.cps);
  if (matchingItems.length < 1) {
    alert("Not enough matching items in inventory!");
    selectedItem = null;
    selectedSource = null;
    updateInventory();
    updateFuelCardList();
    return;
  }
  const emptySlotIndex = altarFuel.findIndex(slot => slot === null);
  if (emptySlotIndex === -1) {
    alert("All fuel slots are filled!");
    selectedItem = null;
    selectedSource = null;
    updateInventory();
    updateFuelCardList();
    return;
  }
  altarFuel[emptySlotIndex] = { ...matchingItems[0] };
  const itemIndex = inventory.findIndex(i => 
    i.name === item.name && i.rarity === item.rarity && i.cps === item.cps
  );
  if (itemIndex !== -1) {
    inventory.splice(itemIndex, 1);
  }
  selectedItem = null;
  selectedSource = null;
  updateInventory();
  updateFuelSlots();
  updateFuelCardList();
  saveGame();
}

    function placeItemInSlot(slotIndex) {
      if (!selectedItem || selectedSource !== 'inventory') {
        alert("Please select an item from the inventory!");
        return;
      }
      if (equipped[slotIndex]) {
        inventory.push(equipped[slotIndex]);
      }
      equipped[slotIndex] = { ...selectedItem };
      const itemIndex = inventory.indexOf(selectedItem);
      if (itemIndex !== -1) {
        inventory.splice(itemIndex, 1);
      }
      selectedItem = null;
      selectedSource = null;
      updateInventory();
      updateSlots();
      saveGame();
    }

    function removeFromEquippedSlot(slotIndex) {
      if (equipped[slotIndex]) {
        inventory.push(equipped[slotIndex]);
        equipped[slotIndex] = null;
        selectedItem = null;
        selectedSource = null;
        updateInventory();
        updateSlots();
        saveGame();
      }
    }

    function updateSlots() {
  const slots = document.getElementById("slots");
  slots.querySelectorAll('.slot').forEach((slot, i) => {
    const slotContent = slot.querySelector('.slot-content');
    slotContent.style.background = ''; // Clear inline background
    if (equipped[i] && equipped[i].rarity && equipped[i].name) {
      slotContent.innerHTML = `
        ${equipped[i].name} ${equipped[i].emoji}<br>
        <span class="description-text">${equipped[i].cps} cps</span>
        <span class="tooltip">${equipped[i].description}</span>
      `;
      slot.className = `slot ${equipped[i].rarity}`;
      slotContent.className = `slot-content ${equipped[i].rarity}`;
    } else {
      slotContent.innerHTML = `Slot ${i + 1}`;
      slot.className = 'slot';
      slotContent.className = 'slot-content';
      slotContent.style.background = 'none';
    }
    slot.onclick = () => {
      if (selectedItem && selectedSource === 'inventory') {
        placeItemInSlot(i);
      } else if (equipped[i]) {
        removeFromEquippedSlot(i);
      }
    };
  });
}

function placeItemInForgeSlot(slotIndex) {
  if (!selectedItem || selectedSource !== 'inventory') {
    alert("Please select an item from the inventory!");
    return;
  }
  if (forgeSlots[slotIndex]) {
    inventory.push(forgeSlots[slotIndex]);
  }
  forgeSlots[slotIndex] = { ...selectedItem };
  const itemIndex = inventory.findIndex(item => 
    item.name === selectedItem.name && item.rarity === selectedItem.rarity && item.cps === selectedItem.cps
  );
  if (itemIndex !== -1) {
    inventory.splice(itemIndex, 1);
  }
  selectedItem = null;
  selectedSource = null;
  updateInventory();
  updateForgeSlots();
  saveGame();
}

    function removeFromForgeSlot(slotIndex) {
      if (forgeSlots[slotIndex]) {
        inventory.push(forgeSlots[slotIndex]);
        forgeSlots[slotIndex] = null;
        selectedItem = null;
        selectedSource = null;
        updateInventory();
        updateForgeSlots();
        saveGame();
      }
    }

    function updateForgeSlots() {
  const slots = document.querySelectorAll('.forge-slot');
  slots.forEach((slot, i) => {
    slot.innerHTML = forgeSlots[i] ? `${forgeSlots[i].name} ${forgeSlots[i].emoji} (${forgeSlots[i].rarity})` : '';
    slot.className = `forge-slot ${forgeSlots[i] ? forgeSlots[i].rarity : ''}`;
    slot.onclick = () => {
      if (forgeSlots[i]) {
        inventory.push(forgeSlots[i]);
        forgeSlots[i] = null;
        updateInventory();
        updateForgeSlots();
        saveGame();
      } else {
        placeItemInForgeSlot(i);
      }
    };
  });
}

    function forgeCards() {
  if (forgeSlots.some(slot => !slot)) {
    alert("Please fill all 3 forge slots!");
    return;
  }

  const allSame = forgeSlots.every((slot, i, arr) => 
    slot.name === arr[0].name && slot.rarity === arr[0].rarity
  );

  if (!allSame) {
    alert("All forge slots must contain the same item (name and rarity)!");
    return;
  }

  const baseItem = forgeSlots[0];
  if (baseItem.rarity === "Special") {
    alert("Special items cannot be forged!");
    return;
  }

  const currentRarityIndex = rarityProgression.indexOf(baseItem.rarity);
  let newRarity = baseItem.rarity;

  if (currentRarityIndex < rarityProgression.length - 1) {
    newRarity = rarityProgression[currentRarityIndex + 1];
  }

  const totalCPS = forgeSlots.reduce((sum, slot) => sum + slot.cps, 0);
  const newItem = {
    ...baseItem,
    rarity: newRarity,
    cps: Math.floor(totalCPS * 4)
  };

  inventory.push(newItem);
  forgeSlots.fill(null);
  selectedItem = null;
  selectedSource = null;
  updateInventory(newItem);
  updateForgeSlots();
  saveGame();
}

    function placeItemInAltarTarget() {
  if (!selectedItem || selectedSource !== 'inventory') {
    alert("Please select a target card from the inventory!");
    return;
  }
  if (altarTarget) {
    inventory.push(altarTarget);
  }
  altarTarget = { ...selectedItem };
  const itemIndex = inventory.findIndex(item => 
    item.name === selectedItem.name && 
    item.rarity === selectedItem.rarity && 
    item.cps === selectedItem.cps
  );
  if (itemIndex !== -1) {
    inventory.splice(itemIndex, 1);
  }
  selectedItem = null;
  selectedSource = null;
  updateInventory();
  updateAltarTarget();
  updateFuelCardList();
  saveGame();
}

    function removeFromAltarTarget() {
      if (altarTarget) {
        inventory.push(altarTarget);
        altarTarget = null;
        selectedItem = null;
        selectedSource = null;
        updateInventory();
        updateAltarTarget();
        saveGame();
      }
    }

    function updateAltarTarget() {
  const targetSlot = document.getElementById("altarTarget");
  targetSlot.style.background = ''; // Clear inline background
  if (altarTarget && altarTarget.rarity && altarTarget.name) {
    targetSlot.innerHTML = `
      ${altarTarget.name} ${altarTarget.emoji}
      <div class="description-text">${altarTarget.cps} cps</div>
      <span class="tooltip">${altarTarget.description}</span>
    `;
    targetSlot.className = `target-slot ${altarTarget.rarity}`;
  } else {
    targetSlot.innerHTML = `Target Slot`;
    targetSlot.className = 'target-slot';
    targetSlot.style.background = 'rgba(255,255,255,0.05)';
  }
  targetSlot.onclick = () => {
    if (selectedItem && selectedSource === 'inventory') {
      placeItemInAltarTarget();
    } else if (altarTarget) {
      removeFromAltarTarget();
    }
  };
}

function placeItemInFuelSlot(slotIndex) {
  if (!selectedItem || selectedSource !== 'inventory') {
    alert("Please select a fuel card from the inventory!");
    return;
  }
  if (altarTarget && selectedItem.name === altarTarget.name && selectedItem.rarity === altarTarget.rarity && selectedItem.cps === altarTarget.cps) {
    alert("Cannot use the target card as a fuel card!");
    return;
  }
  if (altarFuel[slotIndex]) {
    inventory.push(altarFuel[slotIndex]);
  }
  altarFuel[slotIndex] = { ...selectedItem };
  const itemIndex = inventory.findIndex(item => 
    item.name === selectedItem.name && item.rarity === selectedItem.rarity && item.cps === selectedItem.cps
  );
  if (itemIndex !== -1) {
    inventory.splice(itemIndex, 1);
  }
  selectedItem = null;
  selectedSource = null;
  updateInventory();
  updateFuelSlots();
  updateFuelCardList();
  saveGame();
}

    function removeFromFuelSlot(slotIndex) {
      if (altarFuel[slotIndex]) {
        inventory.push(altarFuel[slotIndex]);
        altarFuel[slotIndex] = null;
        selectedItem = null;
        selectedSource = null;
        updateInventory();
        updateFuelSlots();
        saveGame();
      }
    }

    function updateFuelSlots() {
  const slots = document.querySelectorAll('.fuel-slot');
  slots.forEach((slot, i) => {
    slot.innerHTML = altarFuel[i] ? `${altarFuel[i].name} ${altarFuel[i].emoji} (${altarFuel[i].rarity}) ${altarFuel[i].cps} CPS` : '';
    slot.className = `fuel-slot ${altarFuel[i] ? altarFuel[i].rarity : ''}`;
    slot.onclick = () => {
      if (altarFuel[i]) {
        inventory.push(altarFuel[i]);
        altarFuel[i] = null;
        updateInventory();
        updateFuelSlots();
        updateFuelCardList();
        saveGame();
      } else {
        placeItemInFuelSlot(i);
      }
    };
  });
}

function batchSelectFuelCards() {
  const raritySelect = document.getElementById('batchRarity').value;
  const cpsInput = document.getElementById('batchCPS').value;
  const cpsValue = cpsInput ? parseInt(cpsInput) : null;

  if (!raritySelect && (!cpsValue || isNaN(cpsValue) || cpsValue < 0 || cpsValue > 1000)) {
    alert("Please select a rarity or enter a valid CPS (0 to 1000)!");
    document.getElementById('batchCPS').focus();
    return;
  }

  if (inventory.length === 0) {
    alert("Inventory is empty! Add items to use batch selection.");
    updateFuelSlots();
    updateFuelCardList();
    saveGame();
    return;
  }

  // Clear existing fuel slots
  altarFuel.forEach((slotItem, i) => {
    if (slotItem) {
      inventory.push(slotItem);
      altarFuel[i] = null;
    }
  });

  // Filter inventory for matching items
  let matchingItems = inventory.filter(item => {
    const matchesRarity = raritySelect ? item.rarity === raritySelect : true;
    const matchesCPS = cpsValue !== null ? item.cps === cpsValue : true;
    const notTarget = !altarTarget || 
      (item.name !== altarTarget.name || item.rarity !== altarTarget.rarity || item.cps !== altarTarget.cps);
    return matchesRarity && matchesCPS && notTarget;
  });

  if (matchingItems.length === 0) {
    alert("No items match the selected criteria!");
    updateFuelSlots();
    updateFuelCardList();
    saveGame();
    return;
  }

  // Sort by CPS descending
  matchingItems.sort((a, b) => b.cps - a.cps);

  // Fill up to 5 fuel slots
  const fillCount = Math.min(matchingItems.length, altarFuel.length);
  for (let i = 0; i < fillCount; i++) {
    altarFuel[i] = { ...matchingItems[i] };
  }

  // Remove selected items from inventory
  for (let i = 0; i < fillCount; i++) {
    const itemIndex = inventory.findIndex(item => 
      item.name === matchingItems[i].name && 
      item.rarity === matchingItems[i].rarity && 
      item.cps === matchingItems[i].cps
    );
    if (itemIndex !== -1) {
      inventory.splice(itemIndex, 1);
    }
  }

  updateInventory();
  updateFuelSlots();
  updateFuelCardList();
  saveGame();
}

function upgradeCard() {
  if (!altarTarget) {
    alert("Please place a target card in the altar!");
    return;
  }

  const filledFuelSlots = altarFuel.filter(slot => slot !== null);
  if (filledFuelSlots.length < 3) {
    alert("Please place at least 3 fuel cards!");
    return;
  }

  const totalFuelCPS = filledFuelSlots.reduce((sum, item) => sum + item.cps, 0);
  const cpsIncrease = Math.floor(totalFuelCPS * 0.5);
  const newCPS = Math.min(altarTarget.cps + cpsIncrease, 1000);
  altarTarget.cps = newCPS;

  inventory.push({ ...altarTarget });
  altarTarget = null;
  altarFuel.fill(null);

  selectedItem = null;
  selectedSource = null;
  updateInventory();
  updateAltarTarget();
  updateFuelSlots();
  updateFuelCardList();
  saveGame();
  alert(`Card upgraded! New CPS: ${newCPS}`);
}

function redeemCode() {
  const codeInput = document.getElementById('codeInput');
  const code = codeInput.value.trim();
  const encodedCode = btoa(code);

  if (code !== 'keybug02' && redeemedCodes.has(encodedCode)) {
    alert('This code has already been redeemed!');
    return;
  }

  if (code === 'imabeggar') {
    coins += 100;
    spinCost = 10;
    redeemedCodes.add(encodedCode);
    updateSpinButton();
    saveGame();
    alert('Code redeemed! + 1000 coins, spin cost reset.');
  } else if (code === 'ilovehomework') {
    const mcgonagall = items.find(item => item.name === "Professor McGonagall");
    if (mcgonagall) {
      inventory.push({ ...mcgonagall });
      redeemedCodes.add(encodedCode);
      updateInventory();
      showSpecialMessage(mcgonagall);
      saveGame();
      alert('Code redeemed! Professor McGonagall added to inventory.');
    }
  } else if (code == 'Ella') {
    const ella = items.find(item => item.name === "Ella");
    if (ella) {
      inventory.push({...ella});
      redeemedCodes.add(encodedCode);
      updateInventory();
      showSpecialMessage(ella);
      saveGame();
      alert('Code redeemed! Ella added to inventory.');
    }
  } else if (code == 'Nirvi') {
    const nirvi = items.find(item => item.name === "Nirvi");
    if (nirvi) {
      inventory.push({...nirvi});
      redeemedCodes.add(encodedCode);
      updateInventory();
      showSpecialMessage(nirvi);
      saveGame();
      alert('Code redeemed! Nirvi added to inventory.');
    }
  } else if (code == 'Idiot') {
    const idiot = items.find(item => item.name === "Matthew Tan");
    if (idiot) {
      inventory.push({...idiot});
      redeemedCodes.add(encodedCode);
      updateInventory();
      showSpecialMessage(idiot);
      saveGame();
      alert('Code redeemed! Matthew Tan added to inventory.');
    }
  } else if (code === 'Mankai') {
    const bookworm = items.find(item => item.name === "Bookworm");
    if (bookworm) {
      inventory.push({ ...bookworm });
      redeemedCodes.add(encodedCode);
      updateInventory();
      showSpecialMessage(bookworm);
      saveGame();
      alert('Code redeemed! Bookworm added to inventory.');
    }
  } else if (code == 'keybug048') {
    const developer = items.find(item => item.name === "Developer");
    if (developer) {
      inventory.push({...developer});
      redeemedCodes.add(encodedCode);
      updateInventory();
      showSpecialMessage(developer);
      saveGame();
      alert('Code redeemed! ??? added to inventory.');
    }
  } else if (code === 'keybug02') {
    alert('-welcome, developer-');
    addChangelogEntry();
  } else {
    alert('Invalid code!');
  }

  codeInput.value = '';
}
</script>
